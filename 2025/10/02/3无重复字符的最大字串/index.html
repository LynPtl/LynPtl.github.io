<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>3.无重复字符的最大字串 | LynPtl&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="无重复字符的最大子串暴力遍历暴力的思路还是非常简单的，一个n^2的暴力循环。第一个循环是第一位是哪一位，第二个循环是后面满足条件的最大位数。第一反应没能写出来是因为没有想到set。对于稍微有些特别的数据结构并不是特别敏感。   def lengthOfLongestSubstring(s: str) -&gt; int:     n &#x3D; len(s)     max_length &#x3D; 0">
<meta property="og:type" content="article">
<meta property="og:title" content="3.无重复字符的最大字串">
<meta property="og:url" content="https://lynptl.github.io/2025/10/02/3%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AD%97%E4%B8%B2/index.html">
<meta property="og:site_name" content="LynPtl&#39;s Blog">
<meta property="og:description" content="无重复字符的最大子串暴力遍历暴力的思路还是非常简单的，一个n^2的暴力循环。第一个循环是第一位是哪一位，第二个循环是后面满足条件的最大位数。第一反应没能写出来是因为没有想到set。对于稍微有些特别的数据结构并不是特别敏感。   def lengthOfLongestSubstring(s: str) -&gt; int:     n &#x3D; len(s)     max_length &#x3D; 0">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-02T12:18:01.000Z">
<meta property="article:modified_time" content="2025-10-18T13:08:51.784Z">
<meta property="article:author" content="LynPtl">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="LynPtl's Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 8.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">LynPtl&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/image-bed.html">图床</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://LynPtl.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-3无重复字符的最大字串" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/02/3%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AD%97%E4%B8%B2/" class="article-date">
  <time class="dt-published" datetime="2025-10-02T12:18:01.000Z" itemprop="datePublished">2025-10-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      3.无重复字符的最大字串
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="无重复字符的最大子串"><a href="#无重复字符的最大子串" class="headerlink" title="无重复字符的最大子串"></a>无重复字符的最大子串</h1><h2 id="暴力遍历"><a href="#暴力遍历" class="headerlink" title="暴力遍历"></a>暴力遍历</h2><p>暴力的思路还是非常简单的，一个n^2的暴力循环。第一个循环是第一位是哪一位，第二个循环是后面满足条件的最大位数。<br>第一反应没能写出来是因为没有想到set。对于稍微有些特别的数据结构并不是特别敏感。  </p>
<pre><code>def lengthOfLongestSubstring(s: str) -&gt; int:
    n = len(s)
    max_length = 0
    
    # 遍历每个可能的起始位置
    for i in range(n):
        # 使用集合来跟踪已经出现的字符
        char_set = set()
        current_length = 0
        
        # 从起始位置向后扩展
        for j in range(i, n):
            # 如果当前字符已经在集合中，表示遇到了重复字符
            if s[j] in char_set:
                break
            
            # 将当前字符添加到集合中，并增加当前子串长度
            char_set.add(s[j])
            current_length += 1
        
        # 更新最大长度
        max_length = max(max_length, current_length)
    
    return max_length
</code></pre>
<p>但是对于C++而言，这里又要用到stl标准库中的unordered_set&lt;&gt;容器。回想我当时学习C++的时候，几乎就没有怎么用过这些stl容器。。但是对于这种题目使用这种容器几乎是唯一解法，因为不使用stl会使其极度复杂，因为你需要自己定义这种结构体。<br>所以现在学习算法的时候我会顺带学习一下C++的常用stl。<br><a target="_blank" rel="noopener" href="https://www.runoob.com/cplusplus/cpp-libs-unordered_set.html">https://www.runoob.com/cplusplus/cpp-libs-unordered_set.html</a>  </p>
<pre><code>#include &lt;string&gt;
#include &lt;unordered_set&gt;
#include &lt;algorithm&gt;

class Solution {
public:
    int lengthOfLongestSubstring(std::string s) {
        int n = s.length();
        int maxLength = 0;
        
        // 遍历每个可能的起始位置
        for (int i = 0; i &lt; n; i++) {
            // 使用unordered_set来跟踪已经出现的字符
            std::unordered_set&lt;char&gt; charSet;
            int currentLength = 0;
            
            // 从起始位置向后扩展
            for (int j = i; j &lt; n; j++) {
                // 如果当前字符已经在集合中，表示遇到了重复字符
                if (charSet.find(s[j]) != charSet.end()) {
                    break;
                }
                
                // 将当前字符添加到集合中，并增加当前子串长度
                charSet.insert(s[j]);
                currentLength++;
            }
            
            // 更新最大长度
            maxLength = std::max(maxLength, currentLength);
        }
        
        return maxLength;
    }
};
</code></pre>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>理解成一个小窗口在移动，一直划选着符合条件的内容。<br>窗口初始化为0，将第一个元素添加进窗口，随后检测第二个元素是否存在于窗口：<br>如果不存在则添加进窗口。如果存在则循环删除窗口内最左侧元素直到满足条件。<br>满足条件后记录目前的长度并和最大长度进行比较。  </p>
<pre><code>class Solution:
    def lengthOfLongestSubstring(self, s: str) -&gt; int:
        if not s:return 0
        left = 0
        lookup = set()
        n = len(s)
        max_len = 0
        cur_len = 0
        for i in range(n):
            cur_len += 1
            while s[i] in lookup:
                lookup.remove(s[left])
                left += 1
                cur_len -= 1
            if cur_len &gt; max_len:max_len = cur_len
            lookup.add(s[i])
        return max_len

作者：powcai
链接：https://leetcode.cn/problems/longest-substring-without-repeating-characters/solutions/3982/hua-dong-chuang-kou-by-powcai/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。  
</code></pre>
<hr>
<pre><code>class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if(s.size() == 0) return 0;
        unordered_set&lt;char&gt; lookup;
        int maxStr = 0;
        int left = 0;
        for(int i = 0; i &lt; s.size(); i++){
            while (lookup.find(s[i]) != lookup.end()){
                lookup.erase(s[left]);
                left ++;
            }
            maxStr = max(maxStr,i-left+1);
            lookup.insert(s[i]);
    }
        return maxStr;
        
    }
};

作者：powcai
链接：https://leetcode.cn/problems/longest-substring-without-repeating-characters/solutions/3982/hua-dong-chuang-kou-by-powcai/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
</code></pre>
<p>时间复杂度分析：<br>乍一看，这段代码似乎有嵌套循环（外部for循环和内部while循环），可能让人觉得时间复杂度是O(n²)。但实际上，这个算法的总体时间复杂度是O(n)，其中n是字符串的长度。<br>原因如下：</p>
<p>外部的for循环明确执行n次，每次处理字符串中的一个字符。<br>关键在于内部的while循环：虽然它看起来可能在最坏情况下对每个字符都执行多次，但实际上，字符串中的每个字符最多只会被处理两次:</p>
<p>一次是在外部for循环中被添加到窗口（lookup集合）<br>一次是在while循环中被移出窗口</p>
<p>左指针left在整个过程中最多移动n次（从0到n-1）。<br>每次执行while循环体，left指针都会向右移动一位。所以while循环体的总执行次数不会超过n次。</p>
<p>所以，虽然代码中有嵌套的循环结构，但内部while循环的总执行次数受到字符串长度n的限制，使得整体时间复杂度仍然是O(n)。<br>详细解释为什么while循环总执行次数不超过n：</p>
<p>每次执行while循环，left指针都会向右移动一位<br>left指针在整个算法执行过程中只会从0移动到最多n-1<br>因此，while循环的总执行次数不能超过n</p>
<p>空间复杂度：<br>空间复杂度是O(min(m, n))，其中m是字符集的大小，n是字符串长度。因为在最坏情况下，lookup集合最多包含min(m, n)个字符。<br>这就是为什么滑动窗口是解决这类问题的高效方法，它避免了暴力解法中的重复计算，将时间复杂度从O(n²)降低到O(n)。</p>
<p>此外，insert方法和erase方法分别是添加和删除。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://lynptl.github.io/2025/10/02/3%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AD%97%E4%B8%B2/" data-id="cuidiujRPO81rajrjdiDNyM6e" data-title="3.无重复字符的最大字串" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/10/02/1%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          1.两数之和
        
      </div>
    </a>
  
  
    <a href="/2025/10/02/49%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">49.字母异位词分组</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux%E5%85%A5%E9%97%A8/">Linux入门</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/10/">十月 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/10/19/3-Linux%E5%B8%AE%E5%8A%A9%E5%91%BD%E4%BB%A4/">3.Linux帮助命令</a>
          </li>
        
          <li>
            <a href="/2025/10/18/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2025/10/17/2-%E4%BB%8E%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AE%A1%E7%90%86%E6%96%87%E4%BB%B6/">2.从命令行管理文件</a>
          </li>
        
          <li>
            <a href="/2025/10/16/1-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E5%AE%89%E8%A3%85linux/">1.虚拟机和安装linux</a>
          </li>
        
          <li>
            <a href="/2025/10/02/128%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/">128.最长连续序列</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 LynPtl<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/image-bed.html" class="mobile-nav-link">图床</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>