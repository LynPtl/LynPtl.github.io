---
title: 15. 三数之和
date: 2026-02-22 17:38:51
tags:
  - LeetCode
  - Algorithm
  - Two Pointers
  - Array
categories:
  - 算法
mathjax: true
---

# 15 三数之和

> **题目链接：**[15. 三数之和](https://leetcode.cn/problems/3sum/)

## 解题思路

### 方法一：暴力解法（哈希表）

锁定第一个数之后，问题实际上就降级成了我们熟知的**“两数之和”**：寻找剩下的两个数，使它们相加等于固定的这个数的相反数。

不过，此题与普通两数之和存在**两个极具杀伤力的差异**，这也是题目的最大难点：

1. **不能有重复的三元组**：为了方便后续结果去重，在我们开始任何操作之前，必须先**对数组进行升序排序**。
2. **需要跳过重复元素**：在遍历锁定第一个数，以及后续寻找另外两个数时，如果遇到和上一个相同的数字，必须果断跳过（去重），否则就会不可避免地记录重复的解。
``` python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        ans = []

        for i in range(len(nums)):
            if nums[i] > 0:
                break

        # 先对拿到的这个数去重
            if i> 0 and nums[i] == nums[i-1]:
                continue
    
            target = -nums[i]
            visited = set()

            j = i + 1
            while j < len(nums):
                fin = target - nums[j]
                if fin in visited:
                    ans.append([nums[i],nums[j],fin])
                    while j + 1 < len(nums) and nums[j] == nums[j + 1]:
                        j += 1
                visited.add(nums[j])
                j += 1
        return ans
```
![image.png](https://pub-85d4dcece16844bf8290aa4b33608ccd.r2.dev/uploads/1771742677348-vkqm6l-image.png)

> **性能瓶颈分析**：这种基于哈希表的方法整体时间复杂度处于 $O(n^2)$，因为维护 `set` 集合的插入和查找存在常数级耗时；而且它还需要开辟哈希表储存元素，空间复杂度也高达 $O(n)$。在 LeetCode 上的效果非常一般。

### 方法二：排序 + 双指针解法（核心最优解）

既然我们为了去重，第一步早就把整个数组给排好序了。对于一个**有序数组**，寻找两数之和的最佳拍档当然是——**双指针**！

双指针解法的整体外层框架和上面的思路一致：依然是毫无捷径地锁定第一个数 `nums[i]`。主要区别在于，我们在内层寻找另外两个数时，用两端逼近的头尾双指针 `L` 和 `R`，来完美替代那个空间开销极大的哈希表。

**核心滑动逻辑（寻找相反数）：**

- 如果 `sum == 0`：恭喜，找到了一组满分解，把它们打包记录下来。接下来为了寻找下一组可能解，要让 `L` 往右移，`R` 往左移。**注意精髓：移动时务必用 `while` 循环果断跳过所有紧紧挨着的重复数字！**
- 如果 `sum < 0`：说明当前几个数字凑起的总量太小了。由于数组递增，我们需要让左指针 `L` 右移，去捡个更大的数字试试水。
- 如果 `sum > 0`：说明当前的数字总量超标了。同样的原因，需要让右指针 `R` 左移，去试探稍小一点的数字。

``` python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        List = []
        l = len(nums)
        if not nums or l < 3:
            return List
        nums.sort()
        for i in range(l):
            if nums[i] > 0:
                break
            if i > 0 and nums[i] == nums[i-1]:
                continue
            L = i + 1
            R = l - 1
            while(L < R):
                sum = nums[L] + nums[R] + nums[i]
                if sum == 0:
                    List.append([nums[L], nums[R], nums[i]])
                    while L<R and nums[L] == nums[L+1]:
                        L += 1
                    while L<R and nums[R] == nums[R-1]:
                        R -= 1
                    L += 1
                    R -= 1
                elif sum < 0:
                    L += 1
                elif sum >0:
                    R -= 1
        return List
```

![image-compressed.png](https://pub-85d4dcece16844bf8290aa4b33608ccd.r2.dev/uploads/1771742763964-6qy7fj-image-compressed.png)

跑完耗时约为 `615ms`，击败了 49.35% 的用户。

可见，虽然双指针巧妙地把多余的空间打成了 $O(1)$，但核心的时间复杂度依旧是 $O(n^2)$。面对极度刁钻的长数组测试时，我们仍有进一步榨干性能的优化余地。

### 进阶优化：极限剪枝策略

我们可以在最外层固定基准数 `nums[i]` 的大循环中，直接加入经典的**安全剪枝操作**，以此避开大量注定毫无建树的底层遍历：

1. **最小和判断（绝对超标）**：因为数组是排好序递增的，若当前固定的 `nums[i]` 与紧挨着的两个数相加 `nums[i] + nums[i+1] + nums[i+2] > 0`，由于后面的数字只会有增无减，显然以后永远都不可能再凑成 0。这说明这趟游戏直接通关了，可以直接 `break` 结束所有循环。
2. **最大和判断（无可救药）**：如果当前的 `nums[i]` 实在太小，就算天降鸿运让它配上全场最大的两个数字也无济于事，也就是 `nums[i] + nums[-1] + nums[-2] < 0`。此时对于这轮的 `nums[i]` 来说结局已经是失败定局，无需再作无果的挣扎，直接 `continue` 进入下一个 `i` 即可。